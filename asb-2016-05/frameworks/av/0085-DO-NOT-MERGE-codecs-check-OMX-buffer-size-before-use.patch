From 7be9cb74c66db217cc5b63f35636f0bdf8abd1fd Mon Sep 17 00:00:00 2001
From: Wonsik Kim <wonsik@google.com>
Date: Sun, 20 Mar 2016 10:44:44 +0900
Subject: [PATCH 085/182] DO NOT MERGE codecs: check OMX buffer size before use
 in VP8 encoder.

Bug: 27569635
Change-Id: I469573f40e21dc9f4c200749d4f220e3a2d31761
(cherry picked from commit 13fe6cd19e8bc62c6d7fce1d8c279996f19b12a5)
---
 .../codecs/on2/enc/SoftVPXEncoder.cpp              | 26 +++++++++++++++++-----
 1 file changed, 21 insertions(+), 5 deletions(-)

diff --git a/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp b/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp
index 50eb6bf..0eb7440 100644
--- a/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp
+++ b/media/libstagefright/codecs/on2/enc/SoftVPXEncoder.cpp
@@ -757,6 +757,7 @@ void SoftVPXEncoder::onQueueFilled(OMX_U32 portIndex) {
         uint8_t *source =
             inputBufferHeader->pBuffer + inputBufferHeader->nOffset;
 
+        size_t frameSize = mWidth * mHeight * 3 / 2;
         if (mInputDataIsMeta) {
             CHECK_GE(inputBufferHeader->nFilledLen,
                      4 + sizeof(buffer_handle_t));
@@ -788,11 +789,21 @@ void SoftVPXEncoder::onQueueFilled(OMX_U32 portIndex) {
             source = mConversionBuffer;
 
             CHECK_EQ(0, grmodule->unlock(grmodule, handle));
-        } else if (mColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) {
-            ConvertSemiPlanarToPlanar(
-                    source, mConversionBuffer, mWidth, mHeight);
+        } else {
+            if (inputBufferHeader->nFilledLen < frameSize) {
+                android_errorWriteLog(0x534e4554, "27569635");
+                notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);
+                return;
+            } else if (inputBufferHeader->nFilledLen > frameSize) {
+                ALOGW("Input buffer contains too many pixels");
+            }
 
-            source = mConversionBuffer;
+            if (mColorFormat == OMX_COLOR_FormatYUV420SemiPlanar) {
+                ConvertSemiPlanarToPlanar(
+                        source, mConversionBuffer, mWidth, mHeight);
+
+                source = mConversionBuffer;
+            }
         }
         vpx_image_t raw_frame;
         vpx_img_wrap(&raw_frame, VPX_IMG_FMT_I420, mWidth, mHeight,
@@ -844,9 +855,14 @@ void SoftVPXEncoder::onQueueFilled(OMX_U32 portIndex) {
                 outputBufferHeader->nTimeStamp = encoded_packet->data.frame.pts;
                 outputBufferHeader->nFlags = 0;
                 if (encoded_packet->data.frame.flags & VPX_FRAME_IS_KEY)
-                  outputBufferHeader->nFlags |= OMX_BUFFERFLAG_SYNCFRAME;
+                    outputBufferHeader->nFlags |= OMX_BUFFERFLAG_SYNCFRAME;
                 outputBufferHeader->nOffset = 0;
                 outputBufferHeader->nFilledLen = encoded_packet->data.frame.sz;
+                if (outputBufferHeader->nFilledLen > outputBufferHeader->nAllocLen) {
+                    android_errorWriteLog(0x534e4554, "27569635");
+                    notify(OMX_EventError, OMX_ErrorUndefined, 0, 0);
+                    return;
+                }
                 memcpy(outputBufferHeader->pBuffer,
                        encoded_packet->data.frame.buf,
                        encoded_packet->data.frame.sz);
-- 
2.7.4

