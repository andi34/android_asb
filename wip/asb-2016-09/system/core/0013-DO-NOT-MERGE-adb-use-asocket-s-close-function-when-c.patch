From 3854373cab8dde82b76dd683a88ceeff3aedbc61 Mon Sep 17 00:00:00 2001
From: Josh Gao <jmgao@google.com>
Date: Tue, 21 Jun 2016 15:38:14 -0700
Subject: [PATCH 13/20] DO NOT MERGE: adb: use asocket's close function when
 closing.

close_all_sockets was assuming that all registered local sockets used
local_socket_close as their close function. However, this is not true
for JDWP sockets.

Backport of 53eb31d8 and 9b587de.

Bug: http://b/28347842
Change-Id: I13ec6fd87a0691c72608baf6038adcc0f03dca9f
(cherry picked from commit 5218ad36ad30d6a155d68fb779dca20ff220bf54)
---
 adb/Android.mk   |  4 +++-
 adb/mutex_list.h |  1 -
 adb/sockets.c    | 40 +++++++++++++++++-----------------------
 3 files changed, 20 insertions(+), 25 deletions(-)

diff --git a/adb/Android.mk b/adb/Android.mk
index 721b48d..068f744 100644
--- a/adb/Android.mk
+++ b/adb/Android.mk
@@ -84,7 +84,9 @@ ifeq ($(USE_SYSDEPS_WIN32),)
 	LOCAL_STATIC_LIBRARIES += libcutils
 endif
 
-include $(BUILD_HOST_EXECUTABLE)
+ifneq ($(HOST_OS),windows)
+  include $(BUILD_HOST_EXECUTABLE)
+endif
 
 $(call dist-for-goals,dist_files sdk,$(LOCAL_BUILT_MODULE))
 
diff --git a/adb/mutex_list.h b/adb/mutex_list.h
index ff72751..15e383c 100644
--- a/adb/mutex_list.h
+++ b/adb/mutex_list.h
@@ -6,7 +6,6 @@
 #ifndef ADB_MUTEX
 #error ADB_MUTEX not defined when including this file
 #endif
-ADB_MUTEX(socket_list_lock)
 ADB_MUTEX(transport_lock)
 #if ADB_HOST
 ADB_MUTEX(local_transports_lock)
diff --git a/adb/sockets.c b/adb/sockets.c
index f17608b..7b16a30 100644
--- a/adb/sockets.c
+++ b/adb/sockets.c
@@ -20,15 +20,18 @@
 #include <errno.h>
 #include <string.h>
 #include <ctype.h>
+#include <pthread.h>
 
 #include "sysdeps.h"
 
 #define  TRACE_TAG  TRACE_SOCKETS
 #include "adb.h"
 
-ADB_MUTEX_DEFINE( socket_list_lock );
+#if defined(__BIONIC__)
+#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP PTHREAD_RECURSIVE_MUTEX_INITIALIZER
+#endif
 
-static void local_socket_close_locked(asocket *s);
+static pthread_mutex_t socket_list_lock = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
 
 int sendfailmsg(int fd, const char *reason)
 {
@@ -64,14 +67,14 @@ asocket *find_local_socket(unsigned id)
     asocket *s;
     asocket *result = NULL;
 
-    adb_mutex_lock(&socket_list_lock);
+    pthread_mutex_lock(&socket_list_lock);
     for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
         if (s->id == id) {
             result = s;
             break;
         }
     }
-    adb_mutex_unlock(&socket_list_lock);
+    pthread_mutex_unlock(&socket_list_lock);
 
     return result;
 }
@@ -88,12 +91,12 @@ insert_local_socket(asocket*  s, asocket*  list)
 
 void install_local_socket(asocket *s)
 {
-    adb_mutex_lock(&socket_list_lock);
+    pthread_mutex_lock(&socket_list_lock);
 
     s->id = local_socket_next_id++;
     insert_local_socket(s, &local_socket_list);
 
-    adb_mutex_unlock(&socket_list_lock);
+    pthread_mutex_unlock(&socket_list_lock);
 }
 
 void remove_socket(asocket *s)
@@ -116,15 +119,15 @@ void close_all_sockets(atransport *t)
         /* this is a little gross, but since s->close() *will* modify
         ** the list out from under you, your options are limited.
         */
-    adb_mutex_lock(&socket_list_lock);
+    pthread_mutex_lock(&socket_list_lock);
 restart:
     for(s = local_socket_list.next; s != &local_socket_list; s = s->next){
         if(s->transport == t || (s->peer && s->peer->transport == t)) {
-            local_socket_close_locked(s);
+            s->close(s);
             goto restart;
         }
     }
-    adb_mutex_unlock(&socket_list_lock);
+    pthread_mutex_unlock(&socket_list_lock);
 }
 
 static int local_socket_enqueue(asocket *s, apacket *p)
@@ -188,13 +191,6 @@ static void local_socket_ready(asocket *s)
 //    D("LS(%d): ready()\n", s->id);
 }
 
-static void local_socket_close(asocket *s)
-{
-    adb_mutex_lock(&socket_list_lock);
-    local_socket_close_locked(s);
-    adb_mutex_unlock(&socket_list_lock);
-}
-
 // be sure to hold the socket list lock when calling this
 static void local_socket_destroy(asocket  *s)
 {
@@ -224,19 +220,15 @@ static void local_socket_destroy(asocket  *s)
 }
 
 
-static void local_socket_close_locked(asocket *s)
+static void local_socket_close(asocket *s)
 {
+    pthread_mutex_lock(&socket_list_lock);
     D("entered. LS(%d) fd=%d\n", s->id, s->fd);
     if(s->peer) {
         D("LS(%d): closing peer. peer->id=%d peer->fd=%d\n",
           s->id, s->peer->id, s->peer->fd);
         s->peer->peer = 0;
-        // tweak to avoid deadlock
-        if (s->peer->close == local_socket_close) {
-            local_socket_close_locked(s->peer);
-        } else {
-            s->peer->close(s->peer);
-        }
+        s->peer->close(s->peer);
         s->peer = 0;
     }
 
@@ -247,6 +239,7 @@ static void local_socket_close_locked(asocket *s)
         int   id = s->id;
         local_socket_destroy(s);
         D("LS(%d): closed\n", id);
+        pthread_mutex_unlock(&socket_list_lock);
         return;
     }
 
@@ -258,6 +251,7 @@ static void local_socket_close_locked(asocket *s)
     remove_socket(s);
     D("LS(%d): put on socket_closing_list fd=%d\n", s->id, s->fd);
     insert_local_socket(s, &local_socket_closing_list);
+    pthread_mutex_unlock(&socket_list_lock);
 }
 
 static void local_socket_event_func(int fd, unsigned ev, void *_s)
-- 
2.7.4

