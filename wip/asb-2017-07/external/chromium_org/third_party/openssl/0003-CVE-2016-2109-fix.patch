From 765b4c89f0ef664ec9cc463983c7d7b699704239 Mon Sep 17 00:00:00 2001
From: Adam Vartanian <flooey@google.com>
Date: Mon, 10 Apr 2017 15:51:16 +0100
Subject: [PATCH 3/6] CVE 2016-2109 fix

Read ASN.1 data in chunks to prevent invalid inputs from allocating
excessive amounts of data.

Bug: 35443725
Test: run cts -m CtsLibcoreTestCases
Test: manually ran testcase from OpenSSL
Change-Id: Ia9d6aa40726c0cba26e2060108112f33e00e8270
Merged-In: Ie00536d7ad815464b2b031f7bcd1b683e12c1623
Merged-In: If087a69ee075b3c5323abb8d7d740e92bd703bb1
Merged-In: If77e23607fc77f724f50ad0e0b94eef4beae57ea
Merged-In: Ia8d0370ece1d5c1750a4331810c610ed5c813224
Merged-In: Ia945d5ce50335919b0783fe909892703213454ef
(cherry picked from commit ea156ae109eac7b7cf7d4f6a76f3c4590734789b)
---
 openssl/crypto/asn1/a_d2i_fp.c | 43 ++++++++++++++++++++++++++++--------------
 1 file changed, 29 insertions(+), 14 deletions(-)

diff --git a/openssl/crypto/asn1/a_d2i_fp.c b/openssl/crypto/asn1/a_d2i_fp.c
index 52b2ebd..a6980c9 100644
--- a/openssl/crypto/asn1/a_d2i_fp.c
+++ b/openssl/crypto/asn1/a_d2i_fp.c
@@ -139,6 +139,7 @@ void *ASN1_item_d2i_fp(const ASN1_ITEM *it, FILE *in, void *x)
 #endif
 
 #define HEADER_SIZE   8
+#define ASN1_CHUNK_INITIAL_SIZE (16 * 1024)
 static int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)
 	{
 	BUF_MEM *b;
@@ -230,6 +231,7 @@ static int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)
 			want=c.slen;
 			if (want > (len-off))
 				{
+				size_t chunk_max = ASN1_CHUNK_INITIAL_SIZE;
 				want-=(len-off);
 				if (want > INT_MAX /* BIO_read takes an int length */ ||
 					len+want < len)
@@ -237,24 +239,37 @@ static int asn1_d2i_read_bio(BIO *in, BUF_MEM **pb)
 						ASN1err(ASN1_F_ASN1_D2I_READ_BIO,ASN1_R_TOO_LONG);
 						goto err;
 						}
-				if (!BUF_MEM_grow_clean(b,len+want))
-					{
-					ASN1err(ASN1_F_ASN1_D2I_READ_BIO,ERR_R_MALLOC_FAILURE);
-					goto err;
-					}
 				while (want > 0)
 					{
-					i=BIO_read(in,&(b->data[len]),want);
-					if (i <= 0)
-						{
-						ASN1err(ASN1_F_ASN1_D2I_READ_BIO,
-						    ASN1_R_NOT_ENOUGH_DATA);
+
+					 /*
+					 * Read content in chunks of increasing size
+					 * so we can return an error for EOF without
+					 * having to allocate the entire content length
+					 * in one go.
+					 */
+					size_t chunk = want > chunk_max ? chunk_max : want;
+
+					if (!BUF_MEM_grow_clean(b, len + chunk)) {
+						ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ERR_R_MALLOC_FAILURE);
 						goto err;
+					}
+					want -= chunk;
+					while (chunk > 0) {
+						i = BIO_read(in, &(b->data[len]), chunk);
+						if (i <= 0) {
+							ASN1err(ASN1_F_ASN1_D2I_READ_BIO, ASN1_R_NOT_ENOUGH_DATA);
+							goto err;
 						}
-					/* This can't overflow because
-					 * |len+want| didn't overflow. */
-					len+=i;
-					want-=i;
+						/*
+						* This can't overflow because |len+want| didn't
+						* overflow.
+						*/
+						len += i;
+						chunk -= i;
+					}
+					if (chunk_max < INT_MAX/2)
+						chunk_max *= 2;
 					}
 				}
 			if (off + c.slen < off)
-- 
2.7.4

