From cdd0d421c4926873cbfd86a41ec1429cfda2f905 Mon Sep 17 00:00:00 2001
From: Ugo Yu <ugoyu@google.com>
Date: Tue, 30 Oct 2018 00:47:04 +0800
Subject: [PATCH 5/5] Fix possible OOB when AVDT data channel recive ACL data

Bug: 111450156

(cherry picked from commit baa9bf5bfe4a6f3e52ac927aaf4463f37f81294e)

[basilgello: Backported to cm-14.1:
- Aligned avdt_scb_hdl_report() with upstream commit
 8d749047a084b2d8a18fcaaac5c585e97a16f58d
 "Remove casts to unions to avoid unaligned accesses"
- Formatting change to match cm-14.1 style of system/bt
]
Signed-off-by: Vasyl Gello <vasek.gello@gmail.com>

Change-Id: Id23eeedcb7bde5866cd53a2f7f1c30f27c5352f6
---
 stack/avdt/avdt_scb_act.c | 97 ++++++++++++++++++++++++++++++++++++++---------
 1 file changed, 79 insertions(+), 18 deletions(-)

diff --git a/stack/avdt/avdt_scb_act.c b/stack/avdt/avdt_scb_act.c
index 66f9b7d..0f2015b 100644
--- a/stack/avdt/avdt_scb_act.c
+++ b/stack/avdt/avdt_scb_act.c
@@ -23,6 +23,7 @@
  *
  ******************************************************************************/
 
+#include <cutils/log.h>
 #include <string.h>
 #include "data_types.h"
 #include "bt_target.h"
@@ -244,10 +245,14 @@ void avdt_scb_hdl_pkt_no_frag(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
     UINT16  offset;
     UINT16  ex_len;
     UINT8   pad_len = 0;
+    UINT16  len = p_data->p_pkt->len;
 
     p = p_start = (UINT8 *)(p_data->p_pkt + 1) + p_data->p_pkt->offset;
 
     /* parse media packet header */
+    offset = 12;
+    // AVDT_MSG_PRS_OCTET1(1) + AVDT_MSG_PRS_M_PT(1) + UINT16(2) + UINT32(4) + 4
+    if (offset > len) goto length_error;
     AVDT_MSG_PRS_OCTET1(p, o_v, o_p, o_x, o_cc);
     AVDT_MSG_PRS_M_PT(p, m_pt, marker);
     BE_STREAM_TO_UINT16(seq, p);
@@ -255,19 +260,20 @@ void avdt_scb_hdl_pkt_no_frag(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
     BE_STREAM_TO_UINT32(ssrc, p);
 
     /* skip over any csrc's in packet */
+    offset += o_cc * 4;
     p += o_cc * 4;
 
     /* check for and skip over extension header */
     if (o_x)
     {
+        offset += 4;
+        if (offset > len) goto length_error;
         p += 2;
         BE_STREAM_TO_UINT16(ex_len, p);
+        offset += ex_len * 4;
         p += ex_len * 4;
     }
 
-    /* save our new offset */
-    offset = (UINT16) (p - p_start);
-
     /* adjust length for any padding at end of packet */
     if (o_p)
     {
@@ -311,6 +317,12 @@ void avdt_scb_hdl_pkt_no_frag(tAVDT_SCB *p_scb, tAVDT_SCB_EVT *p_data)
             GKI_freebuf(p_data->p_pkt);
         }
     }
+    return;
+length_error:
+    android_errorWriteLog(0x534e4554, "111450156");
+    AVDT_TRACE_WARNING3("%s: hdl packet length %d too short: must be at least %d",
+                       __func__, len, offset);
+    GKI_freebuf(p_data->p_pkt);
 }
 
 #if AVDT_REPORTING == TRUE
@@ -330,14 +342,25 @@ UINT8 * avdt_scb_hdl_report(tAVDT_SCB *p_scb, UINT8 *p, UINT16 len)
     UINT32  ssrc;
     UINT8   o_v, o_p, o_cc;
     UINT16  pkt_len;
+    UINT16  min_len = 0;
+    UINT8   sdes_type;
+    UINT8   name_length;
+
     AVDT_REPORT_TYPE    pt;
-    tAVDT_REPORT_DATA   report, *p_rpt;
+    tAVDT_REPORT_DATA   report;
 
     AVDT_TRACE_DEBUG0( "avdt_scb_hdl_report");
     if(p_scb->cs.p_report_cback)
     {
-        p_rpt = &report;
         /* parse report packet header */
+        min_len += 8;
+        if (min_len > len)
+        {
+            android_errorWriteLog(0x534e4554, "111450156");
+            AVDT_TRACE_WARNING3("%s: hdl packet length %d too short: must be at least %d",
+                               __func__, len, min_len);
+            goto avdt_scb_hdl_report_exit;
+        }
         AVDT_MSG_PRS_RPT_OCTET1(p, o_v, o_p, o_cc);
         pt = *p++;
         BE_STREAM_TO_UINT16(pkt_len, p);
@@ -346,14 +369,29 @@ UINT8 * avdt_scb_hdl_report(tAVDT_SCB *p_scb, UINT8 *p, UINT16 len)
         switch(pt)
         {
         case AVDT_RTCP_PT_SR:   /* the packet type - SR (Sender Report) */
+            min_len += 20;
+            if (min_len > len)
+            {
+                android_errorWriteLog(0x534e4554, "111450156");
+                AVDT_TRACE_WARNING3("%s: hdl packet length %d too short: must be at least %d",
+                                   __func__, len, min_len);
+                goto avdt_scb_hdl_report_exit;
+            }
             BE_STREAM_TO_UINT32(report.sr.ntp_sec, p);
             BE_STREAM_TO_UINT32(report.sr.ntp_frac, p);
             BE_STREAM_TO_UINT32(report.sr.rtp_time, p);
             BE_STREAM_TO_UINT32(report.sr.pkt_count, p);
             BE_STREAM_TO_UINT32(report.sr.octet_count, p);
             break;
-
         case AVDT_RTCP_PT_RR:   /* the packet type - RR (Receiver Report) */
+            min_len += 20;
+            if (min_len > len)
+            {
+                android_errorWriteLog(0x534e4554, "111450156");
+                AVDT_TRACE_WARNING3("%s: hdl packet length %d too short: must be at least %d",
+                                   __func__, len, min_len);
+                goto avdt_scb_hdl_report_exit;
+            }
             report.rr.frag_lost = *p;
             BE_STREAM_TO_UINT32(report.rr.packet_lost, p);
             report.rr.packet_lost &= 0xFFFFFF;
@@ -362,29 +400,52 @@ UINT8 * avdt_scb_hdl_report(tAVDT_SCB *p_scb, UINT8 *p, UINT16 len)
             BE_STREAM_TO_UINT32(report.rr.lsr, p);
             BE_STREAM_TO_UINT32(report.rr.dlsr, p);
             break;
-
         case AVDT_RTCP_PT_SDES: /* the packet type - SDES (Source Description) */
-            if(*p == AVDT_RTCP_SDES_CNAME)
+            min_len += 1;
+            if (min_len > len)
             {
-                p_rpt = (tAVDT_REPORT_DATA *)(p+2);
+                android_errorWriteLog(0x534e4554, "111450156");
+                AVDT_TRACE_WARNING3("%s: hdl packet length %d too short: must be at least %d",
+                                   __func__, len, min_len);
+                goto avdt_scb_hdl_report_exit;
             }
-            else
-            {
-                AVDT_TRACE_WARNING5( " - SDES SSRC=0x%08x sc=%d %d len=%d %s",
-                    ssrc, o_cc, *p, *(p+1), p+2);
+            BE_STREAM_TO_UINT8(sdes_type, p);
+            if (sdes_type == AVDT_RTCP_SDES_CNAME) {
+                min_len += 1;
+                if (min_len > len) {
+                    android_errorWriteLog(0x534e4554, "111450156");
+                    AVDT_TRACE_WARNING3(
+                        "%s: hdl packet length %d too short: must be at least %d",
+                    __func__, len, min_len);
+                    goto avdt_scb_hdl_report_exit;
+                }
+                BE_STREAM_TO_UINT8(name_length, p);
+                if (name_length > len - 2 || name_length > AVDT_MAX_CNAME_SIZE) {
+                    result = AVDT_BAD_PARAMS;
+                } else {
+                    BE_STREAM_TO_ARRAY(p, &(report.cname[0]), name_length);
+                }
+            } else {
+                if (min_len + 1 > len) {
+                    android_errorWriteLog(0x534e4554, "111450156");
+                    AVDT_TRACE_WARNING3(
+                        "%s: hdl packet length %d too short: must be at least %d",
+                        __func__, len, min_len);
+                    goto avdt_scb_hdl_report_exit;
+                }
+                AVDT_TRACE_WARNING5(" - SDES SSRC=0x%08x sc=%d %d len=%d %s", ssrc,
+                                   o_cc, *p, *(p + 1), p + 2);
                 result = AVDT_BUSY;
             }
             break;
-
         default:
-            AVDT_TRACE_ERROR1( "Bad Report pkt - packet type: %d", pt);
+            AVDT_TRACE_ERROR1("Bad Report pkt - packet type: %d", pt);
             result = AVDT_BAD_PARAMS;
         }
-
         if(result == AVDT_SUCCESS)
-            (*p_scb->cs.p_report_cback)(avdt_scb_to_hdl(p_scb), pt, p_rpt);
-
+            (*p_scb->cs.p_report_cback)(avdt_scb_to_hdl(p_scb), pt, &report);
     }
+avdt_scb_hdl_report_exit:
     p_start += len;
     return p_start;
 }
-- 
2.7.4

