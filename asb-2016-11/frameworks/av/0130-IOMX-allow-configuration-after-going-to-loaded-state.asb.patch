From 8f9533245c528d8876f5703abf10f1954c0b3dfe Mon Sep 17 00:00:00 2001
From: Lajos Molnar <lajos@google.com>
Date: Wed, 14 Sep 2016 10:01:37 -0700
Subject: [PATCH 130/182] IOMX: allow configuration after going to loaded state

This was disallowed recently but we still use it as MediaCodcec.stop
only goes to loaded state, and does not free component.

Bug: 31450460
Change-Id: I72e092e4e55c9f23b1baee3e950d76e84a5ef28d
(cherry picked from commit c13904014bfeb56b8a3cc372190bb3a2dd8f1e0d)
---
 media/libstagefright/omx/OMXNodeInstance.cpp | 13 ++++++++++---
 1 file changed, 10 insertions(+), 3 deletions(-)

diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index 457b03b..f39dc82 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -273,8 +273,8 @@ status_t OMXNodeInstance::freeNode(OMXMaster *master) {
 status_t OMXNodeInstance::sendCommand(
         OMX_COMMANDTYPE cmd, OMX_S32 param) {
     if (cmd == OMX_CommandStateSet && param != OMX_StateIdle) {
-        // We do not support returning from unloaded state, so there are no configurations past
-        // first StateSet command. However, OMXCodec supports meta configuration past Stateset:Idle.
+        // Normally there are no configurations past first StateSet; however, OMXCodec supports
+        // meta configuration past Stateset:Idle.
         mSailed = true;
     }
     const sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
@@ -591,7 +591,7 @@ status_t OMXNodeInstance::useBuffer(
                 params, portIndex, false /* copyToOmx */, false /* copyFromOmx */, data);
     } else {
         buffer_meta = new BufferMeta(
-                params, portIndex, false /* copyFromOmx */, false /* copyToOmx */, NULL);
+                params, portIndex, false /* copyToOmx */, false /* copyFromOmx */, NULL);
     }
 
     OMX_BUFFERHEADERTYPE *header;
@@ -1153,6 +1153,13 @@ void OMXNodeInstance::onEvent(
             && arg2 == OMX_StateExecuting) {
         bufferSource->omxExecuting();
     }
+
+    // allow configuration if we return to the loaded state
+    if (event == OMX_EventCmdComplete
+            && arg1 == OMX_CommandStateSet
+            && arg2 == OMX_StateLoaded) {
+        mSailed = false;
+    }
 }
 
 // static
-- 
2.7.4

